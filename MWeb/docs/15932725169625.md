# 面试
## 自我介绍
你好我是本次一面面试官，很高兴你能来参加这次面试，希望在接下来的时间里，我们都能有一次非常愉快的交流。那么，首先，请你简单的介绍下自己。

net
iOS 13年开始

17年 工具类

## 基础知识
好的，接下来我问些iOS的基础知识



### 属性修饰符有哪些?说说区别？
atomic一定安全吗，atomic做了什么
什么时候用copy，不用copy会有什么问题

### 什么是KVC，KVO？KVO底层实现原理？，如果让你自己设计一套KVO，你会怎么做？

### 谈谈你对OC动态性的理解？
如何发送消息的？开发过程中有哪些应⽤？
从Load和Initializer来进⾏分析 类、分类如何加载？


启动过程？（如果谈到了启动这一块，就问问）
### 解决循环引用？

    MRC __block & ARC __weak和unsafe_unretained
为什么 weak的可以解决循环引用，解决timer的强引用?
timer的循环引用，里面如果传递weakSelf还是无法释放，
>weakSelf和self指向地址空间一样，但实际上是不同的两个对象，两个对象同时持有，应该要处理引用计数，但实际上weakself没有处理引用计数，
block里面持有的是一个新的指针地址（weakSelf的指针地址和self的指针地址不一样），block实际并没有真正的持有self的指针空间
而timer里面runloop持有的是weakSelf的指针地址，而weakSelf的指针地址和self的地址实际是一样的。

block为什么要⽤copy？为什么不⽤retain?
block，weak底层实现分别是什么样的？
    三次coypy
weak表存在什么地方？
     -> SideTable 全局静态区

### layoutSubView何时调⽤？
1、初始化⽅法事不会调⽤
2、滚动UIScrollview触发
3、旋转屏幕时触发
4、改变View的值时候触发，前提是frame改变了
5、改变UIView的⼤⼩时触发

### 什么是Runloop？runloop和线程的关系？Runloop如何检测卡顿？图像是如何绘制的？

### iOS实现多线程的⽅式有哪些？
GCD和NSOperation,如何选择？

iOS线程同步的⼯具有哪些？

iOS有哪些锁?
[互斥锁（mutex）和 ⾃旋锁（Spin lock）两种锁适用于不同场景](https://www.jianshu.com/p/4b097aac2c9d)

### 常见crash？如何分析？

### 多媒体（视情况而定）
是否使⽤过CoreText或者CoreImage等？如果使⽤过，请谈谈你使⽤CoreText或者CoreImage的体验？
GPUImage的实现原理是什么？
iOS中有哪些动画

## 设计模式
⾯向对象六⼤原则？在实际中应用如何应用？
⾃⼰写过的组件或开源获官方中⽤到了哪些设计模式？
单例模式有什么缺点

## 项目
谈谈自己项目中优化的经验？具体的数据？
性能优化如何做？思路

项目重构？为什么重构？重构达标的标准？重构遇到的困难？如何解决？
为什么用MVVM，解决什么问题？带来什么问题？


优化：
如何检测性能？如何检测iOS内存问题？
Instrument Time Profile采集数据的两种⽅式？

如何优化iOS应⽤⽹络请求？
如何检测iOS卡顿并定位卡顿函数？



Dyld 加载的步骤
启动？造成APP启动过慢可能的原因有哪些？

组件化成功的标准？
什么才算⼀个好的架构？

图片缓存框架？

## 综合
说一个自己认为做得最好的项目，觉得自己是哪里做得好？
最近在学习什么技能？如何学习？
iOS上你最喜欢什么API？为什么？
wwdc20?

## 编码能力：
如何查找两个子视图的共同父视图？
```
- (NSArray<UIView *> *array)findSuperView:(UIView *)view {
    NSMutableArray *mArray = [NSMutableArray array];
    UIView *temp = [view superView];
    while(temp) {
        [mArray addObject:temp];
        temp = [temp superView];
    }
    return mArray;
}

- (NSArray<UIView *> *array)findCommonSuperView:(UIView *)view otherView:(UIView *)otherView {
    NSArray *viewSuperViews = [self findSuperView:view];
    NSArray *otherViewSuperViews = [self findSuperView:otherView];
    NSMutableArray *mResArray = [NSMutableArray array];
    int i = 0;
    int viewSuperViewCount = [viewSuperViews count];
    int otherViewSuperViewCount = [otherViewSuperViews count];
    //开始查找---> 倒序遍历,因为他们的最顶端的父视图肯定都是UIWindow
    while(i < fmin([viewSuperViews count], [otherViewSuperViews count])) {
        UIView super1 = viewSuperViews[otherViewSuperViewCount - i -1];
        UIView super2 = otherViewSuperViews[otherViewSuperViewCount - i - 1];
        if (super1 == super2) {
            [mResArray addObject:super1];
            i++;
        } else {
            break;
        }
    }
}
```

## 提问环节？
有什么问题吗？

OpenGL


